"use strict";
/**
 * This module defines nodes used to define types and validations for objects and interfaces.
 */
// tslint:disable:no-shadowed-variable prefer-for-of
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;
var util_1 = require("./util");
/** Node that represents a type. */
var TType = /** @class */ (function () {
    function TType() {
    }
    return TType;
}());
exports.TType = TType;
/** Parses a type spec into a TType node. */
function parseSpec(typeSpec) {
    return typeof typeSpec === "string" ? name(typeSpec) : typeSpec;
}
function getNamedType(suite, name) {
    var ttype = suite[name];
    if (!ttype) {
        throw new Error("Unknown type " + name);
    }
    return ttype;
}
/**
 * Defines a type name, either built-in, or defined in this suite. It can typically be included in
 * the specs as just a plain string.
 */
function name(value) { return new TName(value); }
exports.name = name;
var TName = /** @class */ (function (_super) {
    __extends(TName, _super);
    function TName(name) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this._failMsg = "is not a " + name;
        return _this;
    }
    TName.prototype.getChecker = function (suite, strict, allowedProps) {
        var _this = this;
        var ttype = getNamedType(suite, this.name);
        var checker = ttype.getChecker(suite, strict, allowedProps);
        if (ttype instanceof BasicType || ttype instanceof TName) {
            return checker;
        }
        // For complex types, add an additional "is not a <Type>" message on failure.
        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };
    };
    return TName;
}(TType));
exports.TName = TName;
/**
 * Defines a literal value, e.g. lit('hello') or lit(123).
 */
function lit(value) { return new TLiteral(value); }
exports.lit = lit;
var TLiteral = /** @class */ (function (_super) {
    __extends(TLiteral, _super);
    function TLiteral(value) {
        var _this = _super.call(this) || this;
        _this.value = value;
        _this.name = JSON.stringify(value);
        _this._failMsg = "is not " + _this.name;
        return _this;
    }
    TLiteral.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };
    };
    return TLiteral;
}(TType));
exports.TLiteral = TLiteral;
/**
 * Defines an array type, e.g. array('number').
 */
function array(typeSpec) { return new TArray(parseSpec(typeSpec)); }
exports.array = array;
var TArray = /** @class */ (function (_super) {
    __extends(TArray, _super);
    function TArray(ttype) {
        var _this = _super.call(this) || this;
        _this.ttype = ttype;
        return _this;
    }
    TArray.prototype.getChecker = function (suite, strict) {
        var itemChecker = this.ttype.getChecker(suite, strict);
        return function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < value.length; i++) {
                var ok = itemChecker(value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
    };
    return TArray;
}(TType));
exports.TArray = TArray;
/**
 * Defines a tuple type, e.g. tuple('string', 'number').
 */
function tuple() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.tuple = tuple;
var TTuple = /** @class */ (function (_super) {
    __extends(TTuple, _super);
    function TTuple(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        return _this;
    }
    TTuple.prototype.getChecker = function (suite, strict) {
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value[i], ctx);
                if (!ok) {
                    return ctx.fail(i, null, 1);
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TTuple;
}(TType));
exports.TTuple = TTuple;
/**
 * Defines a union type, e.g. union('number', 'null').
 */
function union() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.union = union;
var TUnion = /** @class */ (function (_super) {
    __extends(TUnion, _super);
    function TUnion(ttypes) {
        var _this = _super.call(this) || this;
        _this.ttypes = ttypes;
        var names = ttypes.map(function (t) { return t instanceof TName || t instanceof TLiteral ? t.name : null; })
            .filter(function (n) { return n; });
        var otherTypes = ttypes.length - names.length;
        if (names.length) {
            if (otherTypes > 0) {
                names.push(otherTypes + " more");
            }
            _this._failMsg = "is none of " + names.join(", ");
        }
        else {
            _this._failMsg = "is none of " + otherTypes + " types";
        }
        return _this;
    }
    TUnion.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });
        return function (value, ctx) {
            var ur = ctx.unionResolver();
            for (var i = 0; i < itemCheckers.length; i++) {
                var ok = itemCheckers[i](value, ur.createContext());
                if (ok) {
                    return true;
                }
            }
            ctx.resolveUnion(ur);
            return ctx.fail(null, _this._failMsg, 0);
        };
    };
    return TUnion;
}(TType));
exports.TUnion = TUnion;
/**
 * Defines an intersection type, e.g. intersection('number', 'null').
 */
function intersection() {
    var typeSpec = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        typeSpec[_i] = arguments[_i];
    }
    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));
}
exports.intersection = intersection;
var TIntersection = /** @class */ (function (_super) {
    __extends(TIntersection, _super);
    function TIntersection(tt  ÌÌÌÌÌÌÌÌÌÌÌHŠh   éoDÿÿÌÌÌÌÌÌH‰T$SUHƒì8H‹êH‹À   Hƒ»°    t}H‹Û¤  HÔ¤  H‹@ÿš0  HƒÀH‰E@H›?  HM@èz3ÿÿH‹‹°   H‹E3ÀH‹]@H‰\$ L}6  APH‹@ÿW0  HSèƒÈÿğÁBƒèH‹
H‹H‹@ÿ50  Ç…Ğ    €HYÿÿHƒÄ8][ÃÌH‰T$SUHƒì8H‹êH‹À   Hƒ»°    t}H‹&¤  H¤  H‹@ÿå/  HƒÀH‰EHHF?  HMHèÅ2ÿÿH‹‹°   H‹E3ÀH‹]HH‰\$ LÈ5  APH‹@ÿ¢/  HSèƒÈÿğÁBƒèH‹
H‹H‹@ÿ€/  Ç…Ğ   @ €HMpHÿã-  D  H“ÿÿHƒÄ8][ÃÌÌÌÌÌÌÌHŠè   éÜBÿÿÌÌÌÌÌÌHŠp   Hÿ%¨-  ÌÌÌÌÌÌÌÌÌÌÌHŠH   é±BÿÿÌÌÌÌÌÌH‰T$SUWHƒì0H‹êH‹]HHƒ»°    t}H‹£  H£  H‹@ÿŞ.  HƒÀH‰EpHß?  HMpè¾1ÿÿH‹‹°   H‹E3ÀH‹}pH‰|$ LÁ4  APH‹@ÿ›.  HWèƒÈÿğÁBƒèH‹
H‹H‹@ÿy.  Çƒ8     HÿÿHƒÄ0_][ÃÌH‰T$SUWHƒì0H‹êH‹]HHƒ»°    t}H‹k¢  Hd¢  H‹@ÿ*.  HƒÀH‰E0H+?  HM0è
1ÿÿH‹‹°   H‹E3ÀH‹}0H‰|$ L4  APH‹@ÿç-  HWèƒÈÿğÁBƒèH‹
H‹H‹@ÿÅ-  Çƒ8     Hğ  Hÿ%,  D  HUÿÿHƒÄ0_][ÃÌÌÌÌÌÌÌH‹ŠH   éÍÿÿÌÌÌÌÌÌH‹ŠH   HÁ¸   éäÌÿÿÌÌÌÌÌÌH‹ŠH   HÁØ   é+¨ÿÿÌÌÌÌÌÌH‹ŠH   HÁø   éZ¦ÿÿÌÌÌÌÌÌH‹ŠH   HÁ  éI)ÿÿÌÌÌÌÌÌH‹ŠH   HÁH  éŒÿÿÌÌÌÌÌÌH‹Š0   é²äÿÿÌÌÌÌÌÌHŠğ  Hÿ%Z+  ÌÌÌÌÌÌÌÌÌÌÌH‹Š0   é#ŞÿÿÌÌÌÌÌÌHŠ  é:ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êÇ…¨   @ €H%ÿÿHƒÄ ]ÃÌH‰T$UHƒì H‹êÇ…¨   @ €HM@Hÿä*  D  HÌ$ÿÿHƒÄ ]ÃÌÌÌÌÌÌÌH‹Š¸   éäÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êHN)ÿÿHƒÄ ]ÃÌÌÌÌÌÌÌH‰T$UHƒì H‹êH†*ÿÿHƒÄ ]ÃÌÌÌÌÌÌÌH‹Š(   é®ãÿÿÌÌÌÌÌÌH‹Š(   é&ÿÿÌÌÌÌÌÌHŠ(   é¢9ÿÿÌÌÌÌÌÌH‹Š@   Hÿ%2*  ÌÌÌÌÌÌÌÌÌÌÌH‰T$UHƒì H‹êH‹˜   H‰˜   HƒÁt*3ÒHƒÈÿH÷ñHƒøs3ÒHM@è€5ÿÿHİ†  HM@èÉíÿÿèËâÿÿH‰…¨   Hî6ÿÿHƒÄ ]ÃÌH‰T$UHƒì H‹êE3À²H‹   èŒ8ÿÿ3Ò3ÉèˆíÿÿÌÌÌÌÌÌ@UHƒì H‹êH‹3É8  À”Á‹ÁHƒÄ ]ÃÌÌÌÌÌÌÌH‰T$UHƒì H‹êH¾AÿÿHƒÄ ]ÃÌH‰T$UHƒì H‹êHBÿÿHƒÄ ]ÃÌÌÌÌÌÌÌHŠ@   éŞ@ÿÿÌÌÌÌÌÌHŠ¨   éÌ@ÿÿÌÌÌÌÌÌHŠH   é2IÿÿÌÌÌÌÌÌHŠ    é¸DÿÿÌÌÌÌÌÌHŠ@   éIÿÿÌÌÌÌÌÌH‰T$UHƒì0H‹êHÅJÿÿHƒÄ0]ÃÌH‰T$UHƒì0H‹êH–LÿÿHƒÄ0]ÃÌÌÌÌÌÌÌHŠ€   éÔCÿÿÌÌÌÌÌÌHŠx   éPÿÿÌÌÌÌÌÌHŠ   é|PÿÿÌÌÌÌÌÌH‰T$UHƒì0H‹êHµ^ÿÿHƒÄ0]ÃÌÌÌÌÌÌÌHŠ`   éiHÿÿÌÌÌÌÌÌHŠp   ékCÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹•€   è¤*ÿÿ3Ò3ÉèìëÿÿH‰T$UHƒì H‹ê3Ò3ÉèÕëÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹E`Hƒ  ƒe( Hù…  HM(è¥ëÿÿÌÌÌÌÌÌH‰T$UHƒì0H‹êH
~ÿÿHƒÄ0]ÃÌH‰T$UHƒì0H‹êHÙ}ÿÿHƒÄ0]ÃÌÌÌÌÌÌÌHŠØ   éa„ÿÿÌÌÌÌÌÌHŠ¸   é#{ÿÿÌÌÌÌÌÌHŠP   é~ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êHd‚ÿÿHƒÄ ]ÃÌH‰T$UHƒì H‹êHMXHÿ'  D  H8‚ÿÿHƒÄ ]ÃÌH‰T$UHƒì H‹êH‹M0HÿH&  D  H‚ÿÿHƒÄ ]ÃÌÌÌÌÌÌÌHŠp   é6ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@è:)ÿÿ3Ò3Éè‚êÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@è)ÿÿ3Ò3Éè\êÿÿÌÌÌÌÌÌH‰T$UHƒì0H‹êH†ÿÿHƒÄ0]ÃÌÌÌÌÌÌÌH‰T$UHƒì H‹êH‹EPH‹HH‹	èÇÿÿ‹E(‰E$HU„  HM$èêÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹E`H‹HH‹IèÛÆÿÿ‹E,‰E$H„  HM$èÆéÿÿH‰T$SUHƒì(H‹êH‹]`H‹KH‹Iè¥ÆÿÿH‹KH‹Iè˜Æÿÿ‹E(‰E H×ƒ  HM èƒéÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êHƒe0 HM0è¤šÿÿHM@è›•ÿÿD‹ÀH‹   èäÿÿH‹   è<ÆÿÿH‹…¨   ƒ  H‹…    Hƒ  ‹E(‰E$Hfƒ  HM$èéÿÿÌÌÌÌÌÌHŠ@   é.•ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êHE›ÿÿHƒÄ ]ÃÌÌÌÌÌÌÌH‰T$UHƒì H‹êHƒ¥ˆ    Hˆ   èfœÿÿHM8èÑ”ÿÿD‹ÀH‹MpèÙÿÿH‹Mpè˜Åÿÿ‹E(‰E$H×‚  HM$èƒèÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹M0èeÅÿÿ‹E<‰E(H¤‚  HM(èPèÿÿH‰T$SUHƒì(H‹êH‹]0H‹è4ÅÿÿH‹Ëè,Åÿÿ‹E8‰E$Hk‚  HM$èèÿÿÌÌÌÌÌÌHŠP   éw ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹MpèçÄÿÿ‹E(‰E$H&‚  HM$èÒçÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@èd&ÿÿ3Ò3Éè¬çÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@è>&ÿÿ3Ò3Éè†çÿÿÌÌÌÌÌÌH‹Š@   éÚŸÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹À   èSÄÿÿ‹E8‰E4H’  HM4è>çÿÿH‰T$UHƒì H‹êH‹À   è#ÄÿÿH‹MHèÄÿÿƒe0 H[  HM0èçÿÿÌÌÌÌÌÌHŠ@   é·ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹M0è×Ãÿÿƒe( H  HM(èÄæÿÿÌÌÌÌÌÌHŠ¸   éÜ¶ÿÿÌÌÌÌÌÌHŠX   Hÿ%°"  ÌÌÌÌÌÌÌÌÌÌÌH‰T$UHƒì H‹êH‹M0è{Ãÿÿƒe( H¼€  HM(èhæÿÿÌÌÌÌÌÌHŠ¨   é€¶ÿÿÌÌÌÌÌÌHŠ@   Hÿ%T"  ÌÌÌÌÌÌÌÌÌÌÌHŠ    éU¶ÿÿÌÌÌÌÌÌHŠ`   éC¶ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êHU8è¥ÿÿ‹E(‰E$H:€  HM$èæåÿÿÌÌÌÌÌÌHŠ˜   éşµÿÿÌÌÌÌÌÌHŠP   éìµÿÿÌÌÌÌÌÌHŠ8   é1ÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@èB$ÿÿ3Ò3ÉèŠåÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@è$ÿÿ3Ò3ÉèdåÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹à   èCÂÿÿ‹E`‰EPH‚  HMPè.åÿÿH‰T$UHƒì H‹êH‹MhèÂÿÿH‹ğ   è
Âÿÿ‹EX‰E<HI  HM<èõäÿÿH‰T$UHƒì H‹êH‹ğ   èÚÁÿÿ‹E\‰ELH  HMLèÅäÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êƒe0 Hñ~  HM0èäÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êƒe0 HÉ~  HM0èuäÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@è#ÿÿ3Ò3ÉèOäÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹U@èá"ÿÿ3Ò3Éè)äÿÿÌÌÌÌÌÌH‹Š@   HƒÁéùĞÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êƒe  H?~  HM èëãÿÿÌÌÌÌÌÌHŠ    Hÿ%é  ÌÌÌÌÌÌÌÌÌÌÌH‰T$UHƒì H‹êƒe( Hş}  HM(èªãÿÿÌÌÌÌÌÌH‹Š@   HƒÁéœÿÿÌÌÌÌÌÌH‰T$UHƒì H‹êH‹E@H÷@(  ÿÿu	H‹MPèhÀÿÿ‹E$‰E H§}  HM èSãÿÿÌÌÌÌÌÌ@UHƒì H‹êH‰  H‹‹‰•¤   H‰È   ‰U(‹E(=csmàuH‹•È   ‹M(è*äÿÿ‰E0ëÇE0    ‹E0HƒÄ ]ÃÌ@UHƒì H‹êH‰  H‹‹‰•¨   H‰Ğ   ‰U8‹E8=csmàuH‹•Ğ   ‹M8èÖãÿÿ‰E@ëÇE@    ‹E@HƒÄ ]ÃÌ@UHƒì H‹êH‰  H‹‹‰•¬   H‰Ø   ‰UH‹EH=csmàuH‹•Ø   ‹MHè‚ãÿÿ‰EPëÇEP    ‹EPHƒÄ ]ÃÌ@UHƒì H‹êH‰   H‹‹‰•°   H‰à   ‰UX‹EX=csmàuH‹•à   ‹MXè.ãÿÿ‰E`ëÇE`    ‹E`HƒÄ ]ÃÌ@UHƒì H‹êH‰(  H‹‹‰•´   H‰è   ‰Uh‹Eh=csmàuH‹•è   ‹MhèÚâÿÿ‰EpëÇEp    ‹EpHƒÄ ]ÃÌ@UHƒì H‹êH‰0  H‹‹‰•¸   H‰ğ   ‰Ux‹Ex=csmàuH‹•ğ   ‹Mxè†âÿÿ‰…€   ë
Ç…€       ‹…€   HƒÄ ]ÃÌ@UHƒì H‹êH‰8  H‹‹‰•¼   H‰ø   ‰•ˆ   ‹…ˆ   =csmàuH‹•ø   ‹ˆ   è âÿÿ‰…   ë
Ç…       ‹…   HƒÄ ]ÃÌ@UHƒì H‹êH‰@  H‹‹‰•À   H‰   ‰•˜   ‹…˜   =csmàuH‹•   ‹˜   èºáÿÿ‰…    ë
Ç…        ‹…    HƒÄ ]ÃÌ@UHƒì H‹êƒ½x  w
ÇŞ“  ÿÿÿÿHƒÄ ]ÃÌÌÌÌÌÌÌ@UHƒì H‹ê¹   èSäÿÿHƒÄ ]ÃÌÌÌÌÌÌÌ@UHƒì H‹êH‹3É8  À”Á‹ÁHƒÄ ]ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H‹’  H‹’  ëH‹H…ÒtH‹B@3Éÿv  H‹ç‘  HƒÃH;ØrÜH™  HƒÄ [é5eÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(H-‘  Hÿ  D  H‹B‘  H…ÉtHÿş  D  Hƒ%)‘   ƒ%*‘   ƒ%'‘   HƒÄ(ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰t$WHƒì ƒ=º’  HH‹5›  …‘   ‹ç’  3Û…À~=3ÿH…ÿˆ¹   ;Ø±   H‹¿’  H‹Ö·HÿQ  D  ‹®’  ÿÃHƒÇ;Ø|ÅH‹•’  H…ÉtHÿI  D  Hƒ%|’   ƒ%}’   H>’  ƒ%s’   Hÿ(  D  ƒ%’   H‹M’  H…ÉtHÿ  D  Hƒ%4’   ƒ%5’   ƒ%2’   H‹\$0H‹t$8HƒÄ _ÃÌ¹Œ  Àè;6ÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(€==˜   Hî  H‰˜  tH‹˜  H…ÉtHÿÂ  D  HƒÄ(ÃÌÌÌÌÌÌÌÌH‰  H‰²  ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì ƒ=¿   t]H‹Æ  H‹Ç  ë.H‹;H…ÿt"H‹O H…ÉtH‹H‹@ÿ/  Hƒg  H‹›  HƒÃH;ØrÍH“  Hÿü  D  ƒ%`   H‹\$0HƒÄ _ÃÌ     €   @€   @Ã€   àÃ€   ğP €   °P €   ĞP €   à" €   `* €   P% €   ÀP €   àP €    Q €   ° €   PM €   ğM €   pM €     €   @ €   ° €   @ €   Ğ^ €   0" €   À± €   À± €   À± €   € €   ! €   `  €   à² €   0³ €   P³ €   Q €   ³ €   °³ €    N €    U €   ğU €   V €   PW €   €€    W €    U €   ğU €   p[ €   `€   `€   `€   Ğ[ €   @\ €    L €   °L €    L €   Ğ[ €   @\ €   `€   `€   `€   ] €   @° €   ° €   Ğ^ €   Ğ^ €   À± €   À± €   À± €   À± €    ² €    ² €   €² €   à² €   0³ €   P³ €   À± €   ³ €   °³ €   `€   `€   `€    ° €   `€   `€   `€   Ğ³ €   ğ³ €   ğ³ €   Ğ` €   ğ` €   à" €    f €   ğa €    a €   p… €   `Š €   @Š €   p• €   °‰ €   €‰ €   €• €   ş €   à" €   €• €   À• €   à" €   €• €   @¢ €   à" €   À¨ €   €• €   ş €   À© €   €• €   ş €   ğ` €   €• €   à« €   à" €   €• €   0¬ €   à" €   €• €   €¬ €   à" €   €• €   Ğ¬ €   à" €    ­ €   À­ €   ğ­ €    ® €   °® €   À® €   ğ® €   ¯ €   @¯ €    ¯ €   À¯ €   °» €   `€   °» €   à» €   °» €   0¼ €    ½ €    ¼ €   ğ¼ €   °» €   P¾ €   À` €    U €   ğU €    ß €   €• €   ş €   `€           Ğ_€                  à_€   8              ğ_€                                          `€                                          ``€      €ÿÿÿÿp`€     €ÿÿÿÿ€`€     €ÿÿÿÿ`€     €ÿÿÿÿ˜`€     €ÿÿÿÿ¨`€     €ÿÿÿÿ¸`€     €ÿÿÿÿÈ`€      €ÿÿÿÿğ`€     €ÿÿÿÿa€     €ÿÿÿÿ@a€     €ÿÿÿÿXa€     €ÿÿÿÿˆa€     €ÿÿÿÿ¨a€     €ÿÿÿÿĞa€          Ôa€   @      Øa€          Üa€          àa€   ğa€    b€   0b€   Hb€   `b€   xb€   ˆb€   b€   ¨b€   ¸b€   Ğb€   XQ€   `Q€   ¨Q€                                                                                                 ÀÂ€                   èL€   ğL€   PM€   v        u             O€                                                                                                                  Lº     vº     ˆº     º     ¶º     bº     .·     ì·     Ú·     À·     ¦·     ”·     ‚·     p·     `·     P·     <·             Ş¶     Î¶     ´¶     ¶     
º     n¶     Z¶     F¶     (¶     ¶     ¶     öµ     äµ     Øµ     Ìµ     ü¹     æ¹     Ö¹     Æ¹     ˆ¶     ¾µ     $º     Ì³     Ú³     ê³     ü³     ´     "´     .´     F´     X´     p´     †´     ˜´     ¨´     º´     Ğ´     ì´     µ     µ      µ     aram = TParam;
/**
 * Defines a function parameter list.
 */
var TParamList = /** @class */ (function (_super) {
    __extends(TParamList, _super);
    function TParamList(params) {
        var _this = _super.call(this) || this;
        _this.params = params;
        return _this;
    }
    TParamList.prototype.getChecker = function (suite, strict) {
        var _this = this;
        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });
        var testCtx = new util_1.NoopContext();
        var isParamRequired = this.params.map(function (param, i) {
            return !param.isOpt && !itemCheckers[i](undefined, testCtx);
        });
        var checker = function (value, ctx) {
            if (!Array.isArray(value)) {
                return ctx.fail(null, "is not an array", 0);
            }
            for (var i = 0; i < itemCheckers.length; i++) {
                var p = _this.params[i];
                if (value[i] === undefined) {
                    if (isParamRequired[i]) {
                        return ctx.fail(p.name, "is missing", 1);
                    }
                }
                else {
                    var ok = itemCheckers[i](value[i], ctx);
                    if (!ok) {
                        return ctx.fail(p.name, null, 1);
                    }
                }
            }
            return true;
        };
        if (!strict) {
            return checker;
        }
        return function (value, ctx) {
            if (!checker(value, ctx)) {
                return false;
            }
            return value.length <= itemCheckers.length ? true :
                ctx.fail(itemCheckers.length, "is extraneous", 2);
        };
    };
    return TParamList;
}(TType));
exports.TParamList = TParamList;
/**
 * Single TType implementation for all basic built-in types.
 */
var BasicType = /** @class */ (function (_super) {
    __extends(BasicType, _super);
    function BasicType(validator, message) {
        var _this = _super.call(this) || this;
        _this.validator = validator;
        _this.message = message;
        return _this;
    }
    BasicType.prototype.getChecker = function (suite, strict) {
        var _this = this;
        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };
    };
    return BasicType;
}(TType));
exports.BasicType = BasicType;
/**
 * Defines the suite of basic types.
 */
exports.basicTypes = {
    any: new BasicType(function (v) { return true; }, "is invalid"),
    number: new BasicType(function (v) { return (typeof v === "number"); }, "is not a number"),
    object: new BasicType(function (v) { return (typeof v === "object" && v); }, "is not an object"),
    boolean: new BasicType(function (v) { return (typeof v === "boolean"); }, "is not a boolean"),
    string: new BasicType(function (v) { return (typeof v === "string"); }, "is not a string"),
    symbol: new BasicType(function (v) { return (typeof v === "symbol"); }, "is not a symbol"),
    void: new BasicType(function (v) { return (v == null); }, "is not void"),
    undefined: new BasicType(function (v) { return (v === undefined); }, "is not undefined"),
    null: new BasicType(function (v) { return (v === null); }, "is not null"),
    never: new BasicType(function (v) { return false; }, "is unexpected"),
    Date: new BasicType(getIsNativeChecker("[object Date]"), "is not a Date"),
    RegExp: new BasicType(getIsNativeChecker("[object RegExp]"), "is not a RegExp"),
};
// This approach for checking native object types mirrors that of lodash. Its advantage over
// `isinstance` is that it can still return true for native objects created in different JS
// execution environments.
var nativeToString = Object.prototype.toString;
function getIsNativeChecker(tag) {
    return function (v) { return typeof v === "object" && v && nativeToString.call(v) === tag; };
}
if (typeof Buffer !== "undefined") {
    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, "is not a Buffer");
}
var _loop_1 = function (array_1) {
    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, "is not a " + array_1.name);
};
// Support typed arrays of various flavors
for (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,
    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {
    var array_1 = _a[_i];
    _loop_1(array_1);
}
