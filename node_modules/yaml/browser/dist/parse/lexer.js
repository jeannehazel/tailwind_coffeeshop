import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = '0123456789ABCDEFabcdef'.split('');
const tagChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()".split('');
const invalidFlowScalarChars = ',[]{}'.split('');
const invalidAnchorChars = ' ,[]{}\n\r\t'.split('');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.includes(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            const cs = line.indexOf('#');
            if (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd = cs - 1;
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
        4Û* HÇD$H   H‰D$@H×Ú* H‰D$8H;Û* H‰D$0H‰L$(HMH‰T$ HUèŸ  éıÿÿ‹U A¶ºê‰U @2öH‹E€HMÈD‹ÏM‹ÅH…À…»  Hÿì…* D  ‹Ø=š  À„7  E„ö…„   …Ûˆà   @„ö…ú  H‹MÀH‹]˜HÇE˜    H…ÉurH‹EˆH‰]ÀH…Àt
Ç    H‹]ÀI‹D$H‹MÈI‰L$H‰EÈI‹D$H‰EÀI‰\$H‹M˜ÆEHH…ÉuhHMèöÿÿHM¸èùÿÿ‹Eéşÿÿûš  À…pÿÿÿ‹U é/ÿÿÿHÇEÀ    H‹H‹ ÿeˆ* Hƒ}À „oÿÿÿÌéiÿÿÿL‰}˜H‹H‹ÿDˆ* é©ıÿÿHÇE˜    H‹H‹ ÿ+ˆ* ë‚û4  Àu]‹E¨¨taH‹EˆH…À„YÿÿÿÇ    éNÿÿÿH‹U˜‰]H…Ò„\ıÿÿL‰}˜H‹
H‹H‹Êë™Aƒÿ<†Š  E2ö@¶é´şÿÿè% éIûÿÿû:  Àt›‹E¨û"  ÀuO¨tKH‹EˆH…À„ìşÿÿÇ    éáşÿÿÌéÛûÿÿÌéçûÿÿèô H=/6 éûÿÿH‰D$ HÿÔ‚* D  é;şÿÿH“Ú* ÇEàó  H‰EĞH1+ H"õ* HÇEè    D‹ÃH‰EØHMĞ‰]èç H‹M˜‹]H…É„üÿÿHÇE˜    éºşÿÿH‹M˜‰uH…ÉuHMèåôÿÿHM¸è\÷ÿÿ‹ÆécüÿÿHÇE˜    H‹H‹ ÿÑ†* ëÑA¹   H‰\$0H: H‰D$(L¡"+ H’"+ AIH‰D$ HZ.6 è½p HÆÙ* ÇEà–  H‰EĞHd+ HUô* L‰}èA¸9  ÀH‰EØHMĞÇE9  Àè ‹]é¹ûÿÿA¸   A‹ÏHÁáH¸‰ˆˆˆˆˆˆˆH÷áHç. A¶HÁêA;ĞAGĞAÿÇ‹‘èå=ÿÿ‹ğ…Àˆÿÿÿé0şÿÿH¿V L‰l$0H‰D$(LÆË. HÓÖ* A¹   Hš-6 H‰D$ 3Éèöo éÉüÿÿÌÌÌÌÌÌÌÌÌH‹ÄHƒìhL‹”$    H@XL‹œ$˜   H‰D$XH‹„$¸   H‰D$PH‹„$°   H‰D$HH‹„$¨   H‰D$@H‹„$   L‰T$8L‰\$0H‰D$(L‰L$ M‹ÈL‹Âè   HƒÄhÃÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$ WHƒìpH‹-J6 H3ÄH‰D$`€=g»6  I‹ñH‹œ$°   I‹èH‹ù„À  H…Û„Î  öC„·  ‹C‰G(¨„{  ¸   ğÁY¹6 ÿÀH‰A¹   ‰G,L9Œ$Ğ   LW,LFŒ$Ğ   M…Ét>H‹”$Ø   H‡è   M‹Á€    H‹
HRH‰HğH@H‹JğH‰HàH‹JøH‰HèIƒèuÛIAL‹Œ$    H‰G@HO8H‰OpH\Õ* H‰GHLGHH‰wPHQÕ* H‰G`HbÕ* H‰oXHcb H‰GhHXÕ* H‰GxH½[ H‰‡€   H#Õ* H‰‡   H‘ H‰‡˜   HÕ* H‰‡¨   HåW H‰‡°   H‹„$¨   H‰‡¸   HäÔ* H‰‡À   H*X H‰‡È   H‹ÂL‰—ˆ   L‰    HÇ‡Ğ       Æ H‹Œ$À   H…ÉHÇG     HEÁöG(H‰G0uBH‹L$`H3Ìè†ï L\$pI‹[I‹k I‹s(I‹ã_ÃÌè–Š é6şÿÿH‹Ëè‹ é<şÿÿ3Àé8şÿÿM…ÉL‰D$@H¢Ğ* L‰D$XHvĞ* A¹   HEÁH‹O@H‰D$0H‹„$¸   H…ÀH‰L$8H‰L$PHEĞHD$0H‰T$HE3ÀH‹3ÉH‰D$ èN× H‹„$È   H…À„JÿÿÿH‰G0éAÿÿÿÌÌÌÌÌÌÌÌ@USVWATAUAVAWHl$ÈHì8  H‹„G6 H3ÄH‰E H‹…    E3ÛH‰M M‹ĞH‹¨   H‰EH‹…°   H‰M€L‰I‹ÉL‰M˜DˆL‰D$x‰UÈH‰Eˆèìçÿÿ„À„  A·IZpH‰EğE‹óA·AEŠûH‰EøA‹ûI‹AH‰E H‹CH+HÁøL‰\$HHPÿH‰T$pH…À„§  H‹H4:HÑîH‹ğòIEĞL‹eØEğH‹UĞòMàL‹EàEL‹mòE H‹MòEL‹MH…Ò„ï   H…É„B  fAƒ8‡  A· E·fƒèAE·fAƒÂ fƒøA·fEGfAƒÃ fƒèAfƒøfEGfE;ÓuJE3ÛH…Ò„Á  IƒÀHƒêIƒìL‰EàH‰UĞL‰eØH…É„¦  IƒÁHƒéIƒíL‰ML‰mH‰Mé_ÿÿÿÉƒáşÿÁE3Û…Ét'H;÷…Ò  H‹T$pH;ú…ö  L‹÷…É  EŠûëL‹öA·A‹Ã…Àx!E„ÿ„r  H‹J‹ğA‹ÃëH÷ÙÉA‹Ã…Ày§H‹L$H…ÀxH…Ét+H‹E€H‰A‹ÃH‹M H3ÌèŸì HÄ8  A_A^A]A\_^[]ÃÌL‹t$xM‹†¨   M…À„²  H‹MHUÌL‹M˜3ÀH‰T$0WÀH‰EàHUĞH‹H‰T$(‹UÈEĞH‹@`ÇD$    ÿ€* E3Û‹ø…ÀˆN  ƒ}Ì„6  L‹màLL$@LD$HD‰]èHUğH‹ËA‹óEŠãèO3 ‹È3ÒH¨Ø* …Éˆ  8T$@…'  H‹} ‰UÈH   è€  L‹øH…À„V  HOpL‹ÈDFHUğè;ƒıÿ3Ò…À‹ÊHÈ…Éˆ    H‹CL‹CH‹øH+;HÁÿI;ÀuML+IÁøI‹ÀIƒøÿtIÿÀHƒøÿ¹•  ÀEÊ‹ÁÁè„ÀuHUÈH‹Ëèï  ‹EÈ3Ò…À‹ÊHÈ‹ÁÁè„ÀuH‹CH…À…Î   HƒÀ‹ÊH‰C…Éx%L‹t$HL;÷‚å   H‹‹ÊN‰<ğL‹t$x…ÒxI‹÷‹ÊH«×* …Éˆ  E„ä…¼  ‹Ê…Éˆû   A‹EHMğ‰F0ˆV4HVA‹EH‰EğH‰EøIEH‰E èmÀ E3Û‹Ø…ÀxQH‹E€H‰0A‹†Ğ   ƒøÿ„g  ÿÀA‰†Ğ   L9]à„ÌıÿÿHMĞèa¾ÿÿE3Ûé»ıÿÿH‹L$Hé‹ıÿÿH‰H‹Cé&ÿÿÿL9]àt	HMĞè4¾ÿÿ‹Ãé’ıÿÿ…É:H‹T$pH‹şéüÿÿH‹I+şHÁçL‹ÇJğHJèQ( 3Òéúşÿÿ…Éy<H‹úéïûÿÿH‹ÖH‰T$péâûÿÿLwéóüÿÿH‹EˆÆ éYÿÿÿ‹ùHMĞè‚½ÿÿ‹Çé ıÿÿL‹÷éÍüÿÿH‹EˆÆ é	ıÿÿH‹A´H‹D$HH‹4Áé§şÿÿÌé9üÿÿÌéTüÿÿEĞHEÌD‰]ÌòMàLÿ H‰D$(LE¨D$PH‰ EHß H‰D$ òL$`HL$PòME¨òM¸è† E3Û…Àˆ¶   A‹Ã‹MÌé_üÿÿHGà* ÇD$`C  H¸ß* H‰D$PHäß* H‰L$hA¸•  ÀH‰D$XH¥+ HL$Pès“ 3ÀH9Eàt	HMĞèÂ¼ÿÿ¸•  ÀéüÿÿH©+ ÇD$`M  H‰D$PHe+ HnË* A¸  ÀH‰D$XHL$PHË* H‰D$hè“ ¸  ÀéĞûÿÿ‰EèéEÿÿÿ¹   éŸûÿÿHÕ* ÇD$`&   H‰D$PHT$PH/ H‰D$XHMÈHYñ* H‰D$hèÿ› ‹È3Òé„üÿÿH‰E¨HU¨Hw+/ ÇE¸ú   H‰E°HMèH©s+ A¸5  ÀH‰EÀèz­ ‹È3Òé	ıÿÿÌÌÌÌÌÌÌÌÌ@USVWATAUAVAWH¬$8ıÿÿHì  H‹•@6 H3ÄH‰…°  H‹µ0  E3íD8-Ã±6 M‹ñL‹½8  H‹Ù‰•à   D‰…è   D‰­Ø   D‰­X  Dˆ­h  Ç…8     „í  öô"6 H=å"6 „º  öä"6 L%ùÌ* „   L‰¼$À   H\Ó H‰Œ$¸   H5Ì* H‰„$°   L. H‰´$¨   HN H‰„$    H•Ø   HqÌ* L‹ËH‰„$˜   HG L‰´$   H‰„$ˆ   H|Ë* H‰„$€   H…è   H‰D$xH¥Q H‰D$pHùË* H‰D$hH…à   H‰D$`HuÌ* H‰L$XH0  H‰D$PHÌ* HÇD$H   L‰l$@H‰D$8HGÌ* H‰D$0H‰|$(L‰d$ èKôÿÿM…ÿtE‰/÷…à   üÿÿÿ…  H…ö„®  òK`LM€WÀò  3ÀL…€  ˆ…   º   ó…  H‰E3ÉI‹FE€CPòH…             isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return  HÄª* H‰‡À   H
. H‰‡È   H‹ÂL‰—ˆ   L‰    HÇ‡Ğ       Æ H‹Œ$À   H…ÉHÇG     HEÁöG(H‰G0uBH‹L$`H3ÌèfÅ L\$pI‹[I‹k I‹s(I‹ã_ÃÌèv` é6şÿÿH‹Ëè}a é<şÿÿ3Àé8şÿÿM…ÉL‰D$@H‚¦* L‰D$XHV¦* A¹   HEÁH‹O@H‰D$0H‹„$¸   H…ÀH‰L$8H‰L$PHEĞHD$0H‰T$HE3ÀH‹3ÉH‰D$ è.­ H‹„$È   H…À„JÿÿÿH‰G0éAÿÿÿÌÌÌÌÌÌÌÌH‰\$UHl$©Hì°   H‹k6 H3ÄH‰EOöA(H‹Ùu(€y8 „>  H‹MOH3ÌèmÄ H‹œ$È   HÄ°   ]ÃÌH‹Q@¸   H;ĞHGĞHƒÁHHƒ{  H›¾* H‰EH‹C0H‰E7H‰U'H‰M/H‰U?H‰MG…   H‹ƒ¸   Hƒe× Hƒeï ƒeç H‰EßH‹E_€{8 H‰E÷H¥ß* H‰EÿH‹CX‹HE‰MtH‹LE×A¹   H‰D$ 3Éè!¬ éCÿÿÿL‹LM×3ÒH‰D$(HÇD$    Jè-i éÿÿÿHUHMHÿS* D  H¸Û4¶×‚ŞCH÷mH‹ÊHÁùH‹ÁHÁè?HÈ¸   HDÈH‹EH+C H™H÷ùH‰C Hô¾* H‰Eé"ÿÿÿöA(„¸şÿÿéÑşÿÿÌÌÌÌÌÌÌÌH‰\$H‰t$ WHƒìPH‹æ6 H3ÄH‰D$Hƒd$@ H‹ùeH‹%`   H‹ò3ÒH‹I0DBhHÿÉR* D  H…À„   H‹ÈèïæÿÿH‹ØH…ÛtDH‹×H‹Ëètçÿÿ‹ø…Àˆ€   Hƒ> …š   ‹D$@H‰H‹L$HH3ÌèÂ H‹\$pH‹t$xHƒÄP_ÃÌH+ ÇD$0÷   H‰D$ HŞ* H³* A¸  ÀH‰D$(HL$ HÆ+ H‰D$8èÌl ¸  Àë˜3ÛéfÿÿÿH…ÛtH‹H‹ËH‹‚    º   ÿáU* ‹ÇémÿÿÿÌé`ÿÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌ@USVWATAUAVAWH¬$øıÿÿHìh  H‹¥6 H3ÄH‰…ğ  H‹µ€  E3äH‹½x  A‹ÜD‰elM‹ùD‰¥¨   M‹èDˆ¥¸   L‹ñL‰M€‰UpÇ…ˆ      è¦  H×¼* „À„.  H‰´$Ø   H­ H‰Œ$Ğ   Hi¦* H‰„$È   LbÜ H‰¼$À   H3 H‰„$¸   M‹ÎH½¨* H‰„$°   H…p  H‰„$¨   H£¨* H‰Œ$    H‰„$˜   Hœ/ L‰¼$   H‰„$ˆ   Hq©* H‰„$€   H L‰l$xH‰D$pH=¦* H‰D$hHEpH‰D$`Ht¤* H‰L$XH€   H‰D$PHÈ§* HÇD$H   H‰D$@HÓ©* H‰D$8HÇ§* H‰D$0Hëû5 H‰D$(H‰T$ HUlèpøÿÿH¡»* H…ötD‰&öEp…-  L‹A¾ÿÿÿÿL‰'M;ş‡“  A‹ÇL;ø…L  Aƒü}JL‹OHEhD‹…p  I‹ÍH‹U€ƒeh H‰D$(D‰|$ Hÿ„O* D  ‹Ø=#  Àtc=  €t\…Àu‹EhH‰H…ö„2  …Ûˆ  ¸   ‰H€   Æ…¸   èæúÿÿ‹ElH‹ğ  H3Ìè€¿ HÄh  A_A^A]A\_^[]ÃÌ‹EhHÀI;Æ‡P  D‹øI;Ç…   H‹Ïè¨D „À„  H‹WH…Òu0A‹Ïè¿D H…À„§  H‰GL‰L9?‡‹   AÿÄA¾ÿÿÿÿéúşÿÿL9sìI‹Ïè­D H…ÀuÎHåÛ* ÇEØ’   H‰EÈHMÈHæ* H‰EĞHlá* H‰Eàép  ¸å  À‰El‹ØH€   èúÿÿ‹Ãéÿÿÿû4  À…«  öEpt`¸   éãşÿÿL‰?émÿÿÿ…Û‰ÕşÿÿHÓ¹* ÇEX:  Hm¥* H‰EPH:¹* H‰MHH‰E`HMHD‹Ã‰]lHùÙ* èÌh ‹]lé{ÿÿÿHƒe@ H0¥* H¹* H‰M(HM(H‰E0ÇE85  ë¾¸•  ÀéDÿÿÿöEptH…öt¸   ‰Æ…¸   ë«Hè¤* H‰UH‰MˆHUˆÇE˜  A¸4  ÀL‰e ë-¸å  ÀH½¤* H‰U°H‰M¨HU¨Hâª* ÇE¸  H‰MÀD‹ÀHMlèƒ éËşÿÿ¸•  ÀëÃHpÚ* ÇEø—   H‰EèHMèHå* H‰EğH×ä* H‰E HÙ* A¸  ÀèÑg »  ÀëCH+Ú* ÇE   H‰EHÙØ* HÒä* A¸  ÀH‰EHMHà* H‰E èŒg »  À‰]lé6şÿÿû:  À…¯şÿÿéDşÿÿÌÌÌÌÌÌHƒì(€=î†6  tö\ø5 töWø5 •ÀHƒÄ(ÃÌèÙW ëàH4ø5 èßX ëÛÌÌÌÌÌÌÌÌÌÌÌÌÌ@USVWATAUAVAWH¬$øıÿÿHìh  H‹E6 H3ÄH‰…ğ  L‹­x  3ÀH‹½€  I‹ğ‰E@L‹ù‰…¨   ˆ…¸   H‰Mˆ‰UPD‰MHL‰E0H‰M8Ç…ˆ      èDÿÿÿE3ÉHb¬* „À„2  H‰¼$Ø   H+¨ H‰Œ$Ğ   H¡* H‰„$È   LıÖ L‰¬$À   HÎ H‰„$¸   M‹ÏHX£* H‰„$°   H…p  H‰„$¨   H>£* H‰Œ$    H‰„$˜   HEHH‰„$   H¤* H‰Œ$ˆ   H‰„$€   HE0H‰D$xHÛŸ H‰D$pH× * H‰D$hHEPH‰D$`HŸ* H‰L$XH€   H‰D$PHÊ£* HÇD$H   H‰D$@Hİ£* H‰D$8H)¤* H‰D$0H…ö5 H‰D$(H‰T$ HU@è
óÿÿE3ÉH(«* M‰M H…ÿtD‰ö†Ş   uoD9p  …q  ‹†Ğ   ‹]H;Øƒú   E‹ñM‹ùH‹NpH‹FxH+ÁHÁøL;ørÌJ‹ùIÿÇD8H4uD;ó„“   AÿÆD;óvÍH€   Æ…¸   è­õÿÿ‹E@ëOHÅ¼* H‰UH‰EHMHš°* ÇE I  H‰E(A¸| ÀÇE@| ÀHÓÕ* è¦d ‹]@H€   è[õÿÿ‹ÃH‹ğ  H3Ìèö¹ HÄh  A_A^A]A\_^[]ÃÌL‹HL‹ ‹P0L‰l$ è  E3É…Àˆ
  ‹]HH…ÿ„BÿÿÿÇ   é7ÿÿÿ;Ì   ƒ¢  +ØE‹áE‹ñL9¨   „Ü  WÀ3ÀEXH‰EhI‹    HUpL‹†¨   H‰T$0HUXH‰T$(º   H‹D‰L$ E‹ÌH‹€ˆ   ÿM* E3ÉD‹ø…Àˆ  ƒ}p„®  H‹MhL‰M€‹AH‰EH‰EHAHNpH‰E H‹AH+H©øÿÿÿt!LE€HUèå  E3ÉD‹À…Àˆ7  L9M€uD;ótAÿÆAÿÄD;ó‡°   L‹}ˆé?ÿÿÿ‹•p  E‹ÌH‹MˆL‹†¨   H‰|$0L‰l$(H‹‰    ‰T$ ‹UPH‹H‹€ˆ   ÿPL* E3ÉD‹ø…Ày¢‰E@L9Mht HMXèTŒÿÿWÀ3ÀH‰E EXòE òEhA‹ßé2şÿÿH¶º* H‰U˜H‰EHMÇE M  A¸  ÀL‰M¨ÇE@  ÀéóıÿÿL9Mh„ŸıÿÿHMXèò‹ÿÿé‘ıÿÿH…ÿtÇ   öEP…|ıÿÿHYº* H‰UøH‰EğHMğÇE ç  A¸  €L‰MÇE@  €é–ıÿÿ‰E@‹Øé›ıÿÿÌéşÿÿHº* ÇEÀ¿  H‰E°HU°HÛ§* H‰E¸HĞë. H‰EÈë@H…ÿtÇ   öEP…PÿÿÿHÖ¹* ÇEà¨  H‰EĞHUĞH˜§* L‰MèH‰EØA¸  €HM@è¹| HMX‹ØèÖŠÿÿéıÿÿHMXD‰}@èÄŠÿÿéÂşÿÿÌÌÌÌÌÌÌH‰\$ UVWATAUAVAWHl$ÙHì°   H‹½6 H3ÄH‰EH‰U¯M‹èL‹ùM…ÀtIƒ  H‹A3ÿH+E2öHÁø3ÛL`ÿH…À„I  I‹I4HÑîH‹ğòIEçòM÷òJL‹E÷H‹UçEÿH‹MÿòML‹MH…Ò„   H…É„  fAƒ8‡  A· E·fƒèAE·fAƒÂ fƒøA·fEGfAƒÃ fƒèAfƒøfEGfE;ÓutH…Ò„Ğ   HƒmïIƒÀHƒêL‰E÷H‰UçH…É„¸   IƒÁHƒéHƒmL‰MH‰MÿéhÿÿÿH÷ÙÉ3À…Ày/H‹MH3Ìè½µ H‹œ$  HÄ°   A_A^A]A\_^]ÃÌÉƒáşÿÁ…ÉtH;óu2I;Üu=H‹û…ÉH{ëH‹şA¶3À…ÀxªE„ötI‹H‹ùI‰U 3Àë–…ÉH‹ŞH‹U¯é£şÿÿ…Éy
I‹ÜëîL‹æëéH‹ûëÃÌé*ÿÿÿÌéBÿÿÿEçHE§!}§òM÷L™Î H‰D$(LE·EÏHµT EÿHzÎ H‰D$ òMßHMÏòME·òMÇè©Q …Àx3À‹M§éşşÿÿ¹   éòşÿÿÌÌÌÌÌÌÌÌÌH‰\$UVWAVAWH‹ìHƒìPH‹v6 H3ÄH‰Eøƒeğ ¸ÿÿÿÿH‹uPM‹ùI‹ØD‹òL;Àwx‹ÃH;ØuyIxHƒÿ‚—   H;û‚   H;~vL‹ÆH‹×3ÉèÛ7 …Àx"H‹NL‹ÃH‰>I‹×ƒ! D‰q‰YHƒÁèZÎ' 3ÀH‹MøH3Ìè´ H‹œ$€   HƒÄPA_A^_^]ÃÌA¸•  ÀëA¸å  ÀHg¶* ÇEà   H‰EĞHíâ. H‰EØHªã. ë*HA¶* ÇEà#   H‰EĞA¸•  ÀHÁâ. H‰EØHã. HUĞH‰EèHMğèy ékÿÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$UVWATAUAVAWH¬$ÀıÿÿHì@  H‹26 H3ÄH‰…0  L‹¥   3Û8b}6 I‹ñL‹½°  D‹êH‹½¸  L‹ñL‰MD‰Eˆ‰]0‰˜   ˆ¨   ÇEx   „  ö—î5 Hˆî5 „  ö‡î5 H„­* t@H‰\$PLöÍ H‰\$HLE0H‰\$@3ÒH‰\$8H‰D$0H‰L$(HMpL‰t$ è  HB­* H…ÿt‰A÷Åøÿÿÿ…>  ÷…¨  àÿÿÿ…£  M…ÿ„Ê  òAN`LL$hWÀˆ]8óE@3ÀL…ğ  ò   º   D$hH‰D$x3ÉAFPH‹FH‰\$`…ğ   òH…  ò  èlÑÿÿD‹À…Àˆ‹  HU`HL$hèC  ‹ğ…Àˆó  H‹MH!]ÇE 0   ‹A‰EHE`H‰EH‹AH‰E H‹A A‹ÍƒáH‰E(‹ÑA‹ÅƒÊ$DÑI‹N8‰UHUøH‹H‹@ÿaE* ‹ğ…ÀˆJ  3ÒWÀEPM…ä…V  I‹NHLE4D‹MˆL‰D$HL‹EøH‹L‰D$@D‹…¨  D‰D$8LE8H‹@@H‰T$0HU !\$(H‰T$ ‹UÿùD* ‹ğ…Àˆâ  ‹E4ƒø„>  ƒøurH‹EHHT$`D$hHğ  H!ğ  òL$xH!   H‰…  I‹FHH‰…ø  I‹F8H‰…  …  ò(  èíÿÿ‹Ø…Àˆ’  H‹D$`I‹I‰‹E4H…ÿtƒø……  ‰Æ…¨   H…ÛtH‹H‹ËH‹ ÿAD* HM8è¨´ÿÿHƒ|$x t
HL$hèF„ÿÿHMpèé:ÿÿ‹E0H‹0  H3Ìè;° H‹œ$ˆ  HÄ@  A_A^A]A\_^]ÃÌI9$„ şÿÿHUPI‹ÌèY  ‹ğ…ÀˆÂ  HUPéşÿÿHM8‰u0è*´ÿÿH9\$xt
HL$hèÉƒÿÿ‹ŞëuAöÅ…½şÿÿH!  HÕ™* H‰…ğ  HgË* HHª* Ç…   È   A¸5  ÀH‰…ø  Hğ  ÇE05  ÀèZ ‹]0HM8è²³ÿÿHƒ|$x t
HL$hèPƒÿÿHMpèó9ÿÿ‹ÃéÿÿÿHa™* H‰L$pH‰D$hHğÊ* H1Î* ÇD$x   A¸  ÀH‰E€HL$hÇE0  ÀèY ‹]0ë©ƒø…  ‰émşÿÿè J ééûÿÿH‹Èè'K Hpê5 ééûÿÿHì˜* H‰M H‰E˜HU˜HQÆ. ÇE¨‚   HM0H‰E°èÙJıÿë.H¼˜* H‰MÀH‰E¸HU¸Há…* ÇEÈƒ   HM0H‰EĞè©Jıÿ‹ØéÿÿÿH‡˜* ÇEè•   H‰EØHUØHù¨* H‰EàHM0Hê°* H‰EğèÉs ‹Øë(HL$`‰u0èØışÿHM8èg²ÿÿHL$hèÍÿÿé?şÿÿ‰E0HL$`è³ışÿHM8èB²ÿÿHL$hè¨ÿÿé“şÿÿƒøuÇ   éWıÿÿƒøuÇ   éGıÿÿÌéAıÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌ@USVWATAUAVH¬$ÀşÿÿHì  H‹w6 H3ÄH‰…0  ƒeÀ I‹ùƒe L‹ñ€=¡w6  H‹µ   H‹¨  ‰UÈD‰EĞÆE ÇEè   „	  öëè5 L-Üè5 „ÿ  öÛè5 L%Ÿ* „  H‰œ$À   H“z H‰„$¸   MNğH(’* H‰„$°   L!È H‰´$¨   HB H‰„$    HUÀHg’* H‰„$˜   HMàH‰¼$   HÔ H‰„$ˆ   HU•* H‰„$€   HEĞH‰D$xH H‰D$pHñ‘* H‰D$hHEÈH‰D$`HŒz H‰D$XHD* H‰D$PHÌ‘* HÇD$H   H‰D$@H* H‰D$8HË* H‰D$0L‰l$(L‰d$ è?ºÿÿH…Ûtƒ# ÷EÈøÿÿÿuxH…ö„Û   Hƒ? †  H‹Gfƒ8\…ó   D‹EĞL‹Ï‹UÈI‹NøH‰\$(H‰t$ è  …Àˆ€   HMàÆEè‹­ÿÿ‹EÀH‹0  H3Ìè¹« HÄ  A^A]A\_^[]ÃÌH7:+ L‰e¨H‰E HHÇ* H‰Ê* ÇE°ö  A¸  ÀH‰E¸HM ÇEÀ  ÀèøU ‹]ÀHMàè­ÿÿ‹Ãë‰EÀ‹ØëìèxF éíıÿÿI‹ÍèG éôıÿÿHË9+ L‰eˆH‰E€HU€Hp‚* ÇEø  HMÀH‰E˜è8GıÿëµH›9+ L‰eˆH‰E€HU€H€a. ÇEû  HMÀH‰E˜èGıÿë…ÌÌÌÌÌÌH‰\$UVWATAUAVAWHl$éHì   H‹‰6 H3ÄH‰EH‹]M‹ñL‹ewE‹èD‹úH‹ñH…Ûtƒ# WÀÆEç HUÿI‹ÎóEïèÆ  ‹ø…Àˆ  H‹N8HEÿHƒe· HU§H‰E¿WÀÇE¯0   ÇEÇ@   óEÏH‹H‹@ÿ>* …Àˆû