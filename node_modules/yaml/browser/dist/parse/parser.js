import { tokenType } from './cst.js';
import { Lexer } from './lexer.js';

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !includesToken(it.start, 'explicit-key-ind');
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken)H‹T$ ¹   è Ë  LD$(H‹ĞH‹O èÿb  ‹şL5 L‰t$pH‰t$xfoäC f„$   f‰´$€   foÛC f„$°   @ˆ´$    fo²C fŒ$Ğ   f‰´$À   foÁfŒ$ğ   f‰´$à   fŒ$  f‰´$   fŒ$0  f‰´$   HT$pHL$(è—O  „Àt5H‹CH9CtHT$pH‹Èè¬(  HCĞ   ëLD$pH‹ĞH‹Ëè  ÿÇë¸‹×HQ- è¬Á  L‰t$pHŒ$   èñ´ÿÿHŒ$   èä´ÿÿHŒ$à   è×´ÿÿHŒ$À   èÊ´ÿÿHŒ$    èA¶ÿÿHŒ$€   è°´ÿÿHL$(è¥º  H‹Œ$@  H3Ìè´æ  H‹œ$€  HÄP  A^_^ÃÌH@( HL$@è*šÿÿHïp HL$@èyô  HF( HL$XèšÿÿHÍp HL$XèWô  ÌÌÌÌÌÌÌÌÌÌÌH‰\$VWAVHì€  H‹ù£ H3ÄH‰„$p  H‹úH‹ÙE3öD‰t$@L9qH„J  H‡+ H‰„$   HŒ$@  Hÿ D  ¾   ‰t$@E3ÉE3ÀH”$    HŒ$   HÿÔ D  H‹„$   HcHH# H‰„   H‹„$   HcH‘Pÿÿÿ‰”Œ   H„$    H‰D$HHŒ$    Hÿ¶ D  H¡ H‰„$    Dˆ´$  Dˆ´$  HŒ$    Hÿr D  L‰´$   H‹© H‰„$  L‰´$  H‹SHHƒzrH‹D‹ÆHŒ$    è˜ÃÿÿE3ÀH…ÀH‹„$   HcHH„$   uHÈAPHÿ^ D  ëHÈ3ÒHÿë D  L9´$   „
  HŒ$0  è  H”$    HŒ$@  HÿÛ D  HŒ$    è©ÁÿÿH…Àu*H‹„$   HcHH„$   HÈE3ÀAPHÿ× D  L‰´$€   L‰´$H  LŒ$H  L„$0  º   H) HÿÏ D  …Àˆ	  H‹œ$H  H‹Œ$€   H…ÉtL‰´$€   H‹H‹@ÿĞ L„$€   H!* H‹ËHÿ_ D  …ÀˆH	  Dˆt$1L‰t$xH”$P  HŒ$0  èw  H‹ÈHƒxrH‹H‹œ$€   L‰´$H  HƒÈÿHÿÀfD94AuöºÿÿÿÿH;Â‡‹  P;Ğ‚ø	  ÿÊLŒ$H  L„$0  Hÿö D  …Àˆè  H‹L$xH…ÉtL‰t$xH‹H‹@ÿ H‹LL$1LD$xH‹”$H  H‹ËH‹@8ÿã ‹ØL‰´$H  HŒ$P  è¼°ÿÿ…Ûˆ“  D8t$1„°  L‰t$8H‹L$xH‹HT$8H‹@`ÿ …Àˆµ  L‰t$pH‹\$8L‰´$H  LŒ$H  L„$0  º   H§% Hÿ( D  …Àˆœ  H‹L$pH…ÉtL‰t$pH‹H‹@ÿ7 H‹LD$pH‹”$H  H‹ËH‹@@ÿ …ÀxjH‹\$pL‰´$H  LŒ$H  L„$0  º   HL% Hÿ­ D  …Àˆ)  H‹LD$0H‹”$H  H‹ËH‹@`ÿ» …ÀxD8t$0•ÀˆGL‰t$hH‹\$8L‰´$H  LŒ$H  L„$0  º   H% Hÿ> D  …ÀˆÂ  H‹L$hH…ÉtL‰t$hH‹H‹@ÿM H‹LD$hH‹”$H  H‹ËH‹@@ÿ0 …ÀxjH‹\$hL‰´$H  LŒ$H  L„$0  º   Hš$ HÿÃ D  …ÀˆO  H‹LD$0H‹”$H  H‹ËH‹@`ÿÑ …ÀxD8t$0•ÀˆG	L‰t$PH‹\$8L‰´$H  LŒ$H  L„$0  º   HS$ HÿT D  …Àˆè  H‹L$PH…ÉtL‰t$PH‹H‹@ÿc H‹LD$PH‹”$H  H‹ËH‹@@ÿF …Àˆm  H‹\$PL‰´$H  LŒ$H  L„$0  º   Hä# HÿÕ D  …Àˆq  H‹LD$0H‹”$H  H‹ËH‹@`ÿã …ÀxD8t$0•ÀˆGL‰t$`H‹\$PL‰´$H  LŒ$H  L„$0  º   H­# Hÿf D  …Àˆ
  H‹L$`H…ÉtL‰t$`H‹H‹@ÿu H‹LD$`H‹”$H  H‹ËH‹@@ÿX …ÀxxH‹\$`L‰´$H  LŒ$H  L„$0  º   Hr# Hÿë D  …Àˆ—  H‹LD$HH‹”$H  H‹ËH‹@Xÿù …ÀxòD$Hf.Ş: ztAŠö@ˆw
L‰t$XH‹\$8L‰´$H  LŒ$H  L„$0  º   H# Hÿn D  …Àˆ"  H‹L$XH…ÉtL‰t$XH‹H‹@ÿ} H‹LD$XH‹”$H  H‹ËH‹@@ÿ` …ÀˆÜ   L‰t$HH‹\$XL‰´$H  LŒ$H  L„$0  º   H™" Hÿê D  …Àˆ¦  H‹L$HHÿÉ D  L‰t$HH‹LD$HH‹”$H  H‹ËH‹@Pÿâ …ÀxQ3ÒH‹L$HHÿ‡ D  H‹ĞHŒ$0  è¬ÿÿHOH„$0  H;ÈtH”$0  èëÕÿÿHŒ$0  è}«ÿÿH‹L$HHÿ@ D  L‰t$@H‹\$8L‰´$H  LŒ$H  L„$0  º   Hå! Hÿ D  …ÀˆÒ  H‹L$@H…ÉtL‰t$@H‹H‹@ÿ H‹LD$@H‹”$H  H‹ËH‹@@ÿ  …ÀxjH‹\$@L‰´$H  LŒ$H  L„$0  º   H‚! Hÿ“ D  …Àˆ_  H‹LD$2H‹”$H  H‹ËH‹@`ÿ¡ …ÀxD8t$2•ÀˆGH‹\$8L‰´$H  LŒ$H  L„$0  º   H(! Hÿ) D  …Àˆı  H‹LD$3H‹”$H  H‹ËH‹@`ÿ7 …ÀxD8t$3•ÀˆGH‹L$@H…ÉtL‰t$@H‹H‹@ÿ H‹L$XH…ÉtL‰t$XH‹H‹@ÿî H‹L$`H…ÉtL‰t$`H‹H‹@ÿÑ H‹L$PH…ÉtL‰t$PH‹H‹@ÿ´ H‹L$hH…ÉtL‰t$hH‹H‹@ÿ— H‹L$pH…ÉtL‰t$pH‹H‹@ÿz H‹L$8H…ÉtL‰t$8H‹H‹@ÿ] H‹L$xH…ÉtL‰t$xH‹H‹@ÿ@ H‹Œ$€   H…ÉtL‰´$€   H‹H‹@ÿ HŒ$0  è  HŒ$@  è…  HŒ$@  Hÿò D  H‹Œ$p  H3ÌèìÚ  H‹œ$°  HÄ€  A^_^ÃÌ¹€èEØÿÿH½ HŒ$   èTÿÿHe HŒ$   è è  H¼ HŒ$¸  è+ÿÿHğd HŒ$¸  èwè  ‹Èèë×ÿÿÌH» HŒ$Ğ  èúÿÿH¿d HŒ$Ğ  èFè  ‹Èèº×ÿÿHÚ HŒ$è  èÉÿÿHd HŒ$è  èè  HÚ HŒ$   è¡ÿÿHfd HŒ$   èíç  Hé HŒ$  èxÿÿH=d HŒ$  èÄç  ‹Èè8×ÿÿÌ‹Èè0×ÿÿ‹Èè(×ÿÿÌ‹Èè ×ÿÿ‹Èè×ÿÿÌ‹Èè×ÿÿ‹Èè×ÿÿÌ‹Èè ×ÿÿ‹ÈèøÖÿÿ‹ÈèğÖÿÿ‹ÈèèÖÿÿÌ‹ÈèàÖÿÿÌ‹ÈèØÖÿÿ¹€èÍÖÿÿÌÌÌÌÌÌÌÌÌ@SHƒì H™°   H‹Ëè«  H‹ËHƒÄ [Hÿ% ÌÌÌÌÌÌÌÌÌÌÌÌ@SHƒì H™˜   H‹ƒhÿÿÿHK€HcPH! H‰„hÿÿÿH‹ƒhÿÿÿHcPD‚hÿÿÿD‰„dÿÿÿèş  HKˆHÿ D  H‹ËHƒÄ [Hÿ%£ ÌÌÌÌÌÌÌÌÌÌÌHƒì(H‹ÁH‹	H…ÉtHƒ  H‹H‹@ÿx HƒÄ(ÃÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x AVHƒì 3ÛH‹òH‰YH‹ùH‰YHƒzL‹rrH‹2½   Iƒşs	óëvIîH¸ÿÿÿÿÿÿÿH;èHGèHEH=   r4HH'HƒÊÿH;ÈHFÊè%Ø  H…ÀtHX'HƒãàH‰CøëHÿk D  ÌH…ÀtH‹Èèø×  H‹ØMFH‰H‹ÖH‹Ëè"è  L‰wH‹ÇH‰oH‹\$0H‹l$8H‹t$@H‹|$HHƒÄ A^ÃÌÌÌÌÌÌÌÌÌ@SHƒì H‹PÿÿÿH‹ÙHcPHá H‰„
PÿÿÿH‹PÿÿÿHcPD‚PÿÿÿD‰„
LÿÿÿHÁ`ÿÿÿèû±ÿÿH‹hÿÿÿHƒÄ [Hÿ%x ÌÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XUVWHƒì@H‹úH‰PØ3í‰hÈH‰jHÇB   f‰*Ç@È   D‹ˆ   AöÀucH‹AXH‹H…ÒtWH‹A8L‹H‰T$(H€   HL$(H;HBÈH‹I+ÑHÑúHƒúwwH‹÷HƒrH‹7H‰WHL‹ÃI‹ÑH‹Îèıæ  f‰,3ëWAöÀuQH‹APL‹ M…ÀtEH‹A0L‹H‹AhHcHÒI+ÑIĞHÑúHƒúwH‰WHL‹ÃI‹ÑH‹Ïè¯æ  f‰,;ë	H‹Ïè:ÂÿÿH‹ÇH‹\$pHƒÄ@_^]ÃÌÌÌÌÌÌÌÌÌH‹ÄH‰XD‰@H‰HWHƒì H‹ùƒ` Hº H‰H H‰AHÁ˜   Hÿö D  ÇD$@   H_E3ÀH‹ÓH‹ÏHÿÄ D  H‹HcHHÈ H‰9H‹HcH‘hÿÿÿ‰T9üH‰\$HH‹ËHÿ¼ D  H H‰Hƒch ƒcp H‹ÇH‹\$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰pH‰xL‰p I‹XL‹ÙL‹q8L‹ÒIH‹A@M‹H‹H…Ét
I9KhsI‰KhI‹CI‹ShH‹0H‹ÂH+ÆHÑøH;ØwvH…ÛtAöÁtM…ÀtfAöÁtH…Ét[H<^AöÁtM…ÀtI‰>H+×I‹CPHÑú‰AöÁt2H…Ét-I‹CXHcI‹C@H‹I‹C LQH‰0L+ÇI‹C@IÑøH‰8I‹CXD‰ I‰ëIƒ
ÿIƒb 3ÀH‹\$H‹t$H‹|$L‹t$ I‰BI‹ÂÃÌÌÌÌÌÌÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x AVL‹q8L‹ÙH‹A@I‹èL‹ÒI‹6H‹H…Ét
I9KhsI‰KhI‹CM‹Ch‹T$0I‹ØH‹8H+ßHÑûE…Ét\AƒétAƒù…Ê   H‹ÃëI‹Âƒà<„¸   öÂtH…öu	H…ÿ…¥   H‹ÆH+ÇHÑøëöÂ„‘   H…Éu	H…ÿ…ƒ   H‹ÁëÜ3ÀL(L;ËwsM…ÉtöÂtH…ötdöÂtH…ÉtZJOöÂtH…ötI‰L+ÃI‹CPIÑøD‰ öÂt2H…Ét-I‹CXHcI‹C@H‹I‹C LQH‰8L+ÃI‹C@IÑøH‰I‹CXD‰ M‰
ëIƒ
ÿIƒb H‹\$3ÀH‹l$H‹t$ H‹|$(I‰BI‹ÂA^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌL‹Q8L‹ÉI‹
H…ÉtUI‹QPLcJAH;Ês·ÃÌI‹A@Hƒ8 t6AöApu/I‹QhH;HBH;ÑvI‰QhI‹
I‰
H+ÑI‹APHÑú‰I‹A8H‹ë»¸ÿÿ  ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$H‰l$H‰t$WHƒì H‹A8H‹ù3í·Ú¾ÿÿ  H‹H…ÉtDH‹GH;v;f;òtf;QştöGpu*ƒÊÿH‹ÏHÿü	 D  f;ót
H‹G8H‹f‰fDİ·Ãë·ÆH‹\$0H‹l$8H‹t$@HƒÄ _ÃÌÌÌÌÌÌÌH‹ÄH‰XH‰hH‰pH‰x ATAVAWHƒì öApD·úH‹ÙA¸ÿÿ  …‹  3ífD;Âu·Åé  H‹A@L‹0H‹AXHcINM…öt)L;òs$H‹ËHÿf D  fD‰8IFH‰ChA·Çé?  H‹CH‹ıA¼    H‹0M…öt,H‹úH+şHÑÿI;ürHÿÿÿÿ?sL$?ëA¼ÿÿÿI;üƒú   I‹Ôè—°ÿÿHÿH‹ÖL‹ÇH‹ÈL‹ğèFá  J7HJH‰KhH‹K L‰1H‹K@H‰K$H‹CXH+ÊIÎHÑù‰öCptH‹CL‰0H‹C8IÑşH‰(H‹CPD‰0ë0H‹C8L‹ChH‹H‹CH+ÎHÑùL‰0H‹C8INL+ÂIÑøH‰H‹CPD‰ ‹Cp¨t/Hÿ   rH‹NøHƒÇ'H+ñHFøHƒøw/H‹ñH‹×H‹Îè›Ğ  ‹CpƒÈH‹Ë‰CpHÿ, D  fD‰8éÉşÿÿHÿ D  ÌA·ÀH‹\$@H‹l$HH‹t$PH‹|$XHƒÄ A_A^A\ÃÌÌÌÌÌÌÌÌÌÌ@SHƒì öApH[ı  H‰H‹ÙtaH‹A@H‹H…ÒtH‹AXHcHJëH‹APHcH‹A8H‹HQH‹CH‹H+ÑHÑúHÒHú   rL‹AøHƒÂ'I+ÈHAøHƒøwSI‹ÈèÆÏ  H‹CH‹ËHƒ  H‹C8Hƒ  H‹CPƒ  H‹C Hƒ  H‹C@Hƒ  H‹CXƒ  Hƒch ƒcpşHƒÄ [Hÿ%ô ÌÌÌÌÌHÿ D  ÌÌÌÌÌÌÌH‰\$H‰t$WHƒì ‹úH±PÿÿÿH‹ÙèP÷ÿÿH‹ËHÿÂ D  @öÇtº  H‹Îè&Ï  H‹\$0H‹ÆH‹t$8HƒÄ _ÃÌÌÌÌÌÌÌH‰\$WHƒì H¹hÿÿÿ‹ÚH‹ÏèiõÿÿöÃtºø   H‹ÏèßÎ  H‹\$0H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‰\$WHƒì ‹ÚH‹ùèhşÿÿöÃtºx   H‹Ïè–Î  H‹\$0H‹ÇHƒÄ _ÃÌÌÌÌÌÌÌÌI;ĞttH‰\$WHƒì I‹øHš   H|û  HK H‰ƒpÿÿÿèÄ›ÿÿH‹Ëè¼›ÿÿHKàè³›ÿÿHKÀèª›ÿÿHK è%ÿÿHK€è˜›ÿÿHÃĞ   HƒpÿÿÿH;ÇuªH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌÌI;ĞtIH‰\$H‰t$WHƒì I‹ğH‹úHÏû  HO0H‰èC›ÿÿHOè:›ÿÿHƒÇPH;şuÛH‹\$0H‹t$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌI;ĞtIH‰\$H‰t$WHƒì I‹ğH‹úH—ú  HO(H‰èëšÿÿHOèâšÿÿHƒÇHH;şuÛH‹\$0H‹t$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌI;ĞtIH‰\$H‰t$WHƒì I‹ğH‹úH×ù  HO(H‰èœÿÿHOèŠšÿÿHƒÇHH;şuÛH‹\$0H‹t$8HƒÄ _ÃÌÌÌÌÌÌÌÌÌI;ĞtYH‰\$WHƒì I‹øHZHHÓú  HK H‰C¸è>šÿÿH‹Ëè6šÿÿHKàè±›ÿÿHKÀè¨›ÿÿHÃ    HC¸H;ÇuÂH‹\$0HƒÄ _ÃÌÌÌÌÌÌÌÌÌH‰T$SVWATAUAVAWHƒì`M‹ğH‹ùH+IºÅNìÄNìÄNI‹ÂH÷êH‹òHÁşH‹ÆHÁè?HğH‹IH+I‹ÂH÷éH‹ÊHÁùH‹ÁHÁè?HÈH‰L$0I¹;±;±;I;É„V  LAH‹OH+I‹ÂH÷éHÁúH‹ÂHÁè?HĞH‹ÊHÑéI‹ÁH+ÁH;ĞvM‹øëL<M;øMBøL‰¼$¸   IiÇĞ   HƒÊÿM;ùHGÂH=   r'HH'H;ÈHFÊèbË  H…À„Î  HX'HƒãàH‰CøëH…ÀtH‹Èè>Ë  H‹Øë3ÛH‰\$@LiîĞ   LëL‰l$(M¥Ğ   L‰d$8L‰¤$    I‹ÖI‹Íè8  L‰¬$    H‹OH‰L$ H‹7H‹„$¨   H‰\$HH‰\$PH‰|$XH;Áu-L‹ãA¾Ğ   H;ñtH‹ÖI‹Ìèï  MæL‰d$PIöH‹L$ ëŞë{L‹ëA¾Ğ   H;ğt H‹ÖI‹ÍèÂ  MîL‰l$PIöH‹„$¨   ëÛH‰œ$    H‹wL‰d$HL‰d$PH‰|$XH;Æt(H‹ĞI‹Ìè‚  MæL‰d$PH‹„$¨   IÆH‰„$¨   ëÓL‹l$(H‹H…Òt^L‹GèßûÿÿL‹H‹OI+ÈH¸ÅNìÄNìÄNH÷éHÁúH‹ÂHÁè?HĞHiÒĞ   Hú   rHƒÂ'I‹HøL+ÁI@øHƒøwFL‹ÁI‹Èè
Ê  H‰H‹D$0HÿÀHiÈĞ   HËH‰OIiÏĞ   HËH‰OI‹ÅHƒÄ`A_A^A]A\_^[ÃÌHÿäı  D  Ìèí·ÿÿÌÌÌÌÌÌÌÌÌ@SVWATAUAVAWHƒì`M‹ğL‹êL‹áH+IºgfffffffI‹ÂH÷êH‹úHÁÿH‹ÇHÁè?HøH‹II+$I‹ÂH÷éH‹ÊHÁùH‹ÁHÁè?HÈH‰Œ$¸   I¹3333333I;É„U  LAI‹L$I+$I‹ÂH÷éHÁúH‹ÂHÁè?HĞH‹ÊHÑéI‹ÁH+ÁH;ĞvM‹øëL<M;øMBøL‰¼$¨   K¿HÁàHƒÊÿM;ùHGÂH=   r0HH'H;ÈHFÊè„È  H…ÀtHX'HƒãàH‰CøëHÿÊü  D  Ì3ÛH…ÀtH‹ÈèU                  }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

export { Parser };
